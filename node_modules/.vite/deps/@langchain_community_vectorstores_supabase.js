import {
  CallbackManager,
  Runnable,
  Serializable,
  ensureConfig,
  parseCallbackConfigArg
} from "./chunk-WKFOUCAC.js";
import {
  __commonJS,
  __export,
  __toESM
} from "./chunk-ROME4SDB.js";

// node_modules/binary-search/index.js
var require_binary_search = __commonJS({
  "node_modules/binary-search/index.js"(exports, module) {
    module.exports = function(haystack, needle, comparator, low, high) {
      var mid, cmp;
      if (low === void 0)
        low = 0;
      else {
        low = low | 0;
        if (low < 0 || low >= haystack.length)
          throw new RangeError("invalid lower bound");
      }
      if (high === void 0)
        high = haystack.length - 1;
      else {
        high = high | 0;
        if (high < low || high >= haystack.length)
          throw new RangeError("invalid upper bound");
      }
      while (low <= high) {
        mid = low + (high - low >>> 1);
        cmp = +comparator(haystack[mid], needle, mid, haystack);
        if (cmp < 0)
          low = mid + 1;
        else if (cmp > 0)
          high = mid - 1;
        else
          return mid;
      }
      return ~low;
    };
  }
});

// node_modules/num-sort/index.js
var require_num_sort = __commonJS({
  "node_modules/num-sort/index.js"(exports) {
    "use strict";
    function assertNumber(number) {
      if (typeof number !== "number") {
        throw new TypeError("Expected a number");
      }
    }
    exports.ascending = (left, right) => {
      assertNumber(left);
      assertNumber(right);
      if (Number.isNaN(left)) {
        return -1;
      }
      if (Number.isNaN(right)) {
        return 1;
      }
      return left - right;
    };
    exports.descending = (left, right) => {
      assertNumber(left);
      assertNumber(right);
      if (Number.isNaN(left)) {
        return 1;
      }
      if (Number.isNaN(right)) {
        return -1;
      }
      return right - left;
    };
  }
});

// node_modules/@langchain/core/dist/retrievers/index.js
var BaseRetriever = class extends Runnable {
  constructor(fields) {
    super(fields);
    Object.defineProperty(this, "callbacks", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "tags", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "metadata", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "verbose", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.callbacks = fields == null ? void 0 : fields.callbacks;
    this.tags = (fields == null ? void 0 : fields.tags) ?? [];
    this.metadata = (fields == null ? void 0 : fields.metadata) ?? {};
    this.verbose = (fields == null ? void 0 : fields.verbose) ?? false;
  }
  /**
   * TODO: This should be an abstract method, but we'd like to avoid breaking
   * changes to people currently using subclassed custom retrievers.
   * Change it on next major release.
   */
  _getRelevantDocuments(_query, _callbacks) {
    throw new Error("Not implemented!");
  }
  async invoke(input, options) {
    return this.getRelevantDocuments(input, ensureConfig(options));
  }
  /**
   * @deprecated Use .invoke() instead. Will be removed in 0.3.0.
   *
   * Main method used to retrieve relevant documents. It takes a query
   * string and an optional configuration object, and returns a promise that
   * resolves to an array of `Document` objects. This method handles the
   * retrieval process, including starting and ending callbacks, and error
   * handling.
   * @param query The query string to retrieve relevant documents for.
   * @param config Optional configuration object for the retrieval process.
   * @returns A promise that resolves to an array of `Document` objects.
   */
  async getRelevantDocuments(query, config) {
    const parsedConfig = ensureConfig(parseCallbackConfigArg(config));
    const callbackManager_ = await CallbackManager.configure(parsedConfig.callbacks, this.callbacks, parsedConfig.tags, this.tags, parsedConfig.metadata, this.metadata, { verbose: this.verbose });
    const runManager = await (callbackManager_ == null ? void 0 : callbackManager_.handleRetrieverStart(this.toJSON(), query, parsedConfig.runId, void 0, void 0, void 0, parsedConfig.runName));
    try {
      const results = await this._getRelevantDocuments(query, runManager);
      await (runManager == null ? void 0 : runManager.handleRetrieverEnd(results));
      return results;
    } catch (error) {
      await (runManager == null ? void 0 : runManager.handleRetrieverError(error));
      throw error;
    }
  }
};

// node_modules/@langchain/core/dist/vectorstores.js
var VectorStoreRetriever = class extends BaseRetriever {
  static lc_name() {
    return "VectorStoreRetriever";
  }
  get lc_namespace() {
    return ["langchain_core", "vectorstores"];
  }
  _vectorstoreType() {
    return this.vectorStore._vectorstoreType();
  }
  constructor(fields) {
    super(fields);
    Object.defineProperty(this, "vectorStore", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "k", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4
    });
    Object.defineProperty(this, "searchType", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "similarity"
    });
    Object.defineProperty(this, "searchKwargs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "filter", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.vectorStore = fields.vectorStore;
    this.k = fields.k ?? this.k;
    this.searchType = fields.searchType ?? this.searchType;
    this.filter = fields.filter;
    if (fields.searchType === "mmr") {
      this.searchKwargs = fields.searchKwargs;
    }
  }
  async _getRelevantDocuments(query, runManager) {
    if (this.searchType === "mmr") {
      if (typeof this.vectorStore.maxMarginalRelevanceSearch !== "function") {
        throw new Error(`The vector store backing this retriever, ${this._vectorstoreType()} does not support max marginal relevance search.`);
      }
      return this.vectorStore.maxMarginalRelevanceSearch(query, {
        k: this.k,
        filter: this.filter,
        ...this.searchKwargs
      }, runManager == null ? void 0 : runManager.getChild("vectorstore"));
    }
    return this.vectorStore.similaritySearch(query, this.k, this.filter, runManager == null ? void 0 : runManager.getChild("vectorstore"));
  }
  async addDocuments(documents, options) {
    return this.vectorStore.addDocuments(documents, options);
  }
};
var VectorStore = class extends Serializable {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  constructor(embeddings, dbConfig) {
    super(dbConfig);
    Object.defineProperty(this, "lc_namespace", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ["langchain", "vectorstores", this._vectorstoreType()]
    });
    Object.defineProperty(this, "embeddings", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.embeddings = embeddings;
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  async delete(_params) {
    throw new Error("Not implemented.");
  }
  async similaritySearch(query, k = 4, filter = void 0, _callbacks = void 0) {
    const results = await this.similaritySearchVectorWithScore(await this.embeddings.embedQuery(query), k, filter);
    return results.map((result) => result[0]);
  }
  async similaritySearchWithScore(query, k = 4, filter = void 0, _callbacks = void 0) {
    return this.similaritySearchVectorWithScore(await this.embeddings.embedQuery(query), k, filter);
  }
  static fromTexts(_texts, _metadatas, _embeddings, _dbConfig) {
    throw new Error("the Langchain vectorstore implementation you are using forgot to override this, please report a bug");
  }
  static fromDocuments(_docs, _embeddings, _dbConfig) {
    throw new Error("the Langchain vectorstore implementation you are using forgot to override this, please report a bug");
  }
  asRetriever(kOrFields, filter, callbacks, tags, metadata, verbose) {
    if (typeof kOrFields === "number") {
      return new VectorStoreRetriever({
        vectorStore: this,
        k: kOrFields,
        filter,
        tags: [...tags ?? [], this._vectorstoreType()],
        metadata,
        verbose,
        callbacks
      });
    } else {
      const params = {
        vectorStore: this,
        k: kOrFields == null ? void 0 : kOrFields.k,
        filter: kOrFields == null ? void 0 : kOrFields.filter,
        tags: [...(kOrFields == null ? void 0 : kOrFields.tags) ?? [], this._vectorstoreType()],
        metadata: kOrFields == null ? void 0 : kOrFields.metadata,
        verbose: kOrFields == null ? void 0 : kOrFields.verbose,
        callbacks: kOrFields == null ? void 0 : kOrFields.callbacks,
        searchType: kOrFields == null ? void 0 : kOrFields.searchType
      };
      if ((kOrFields == null ? void 0 : kOrFields.searchType) === "mmr") {
        return new VectorStoreRetriever({
          ...params,
          searchKwargs: kOrFields.searchKwargs
        });
      }
      return new VectorStoreRetriever({ ...params });
    }
  }
};

// node_modules/@langchain/core/dist/documents/document.js
var Document = class {
  constructor(fields) {
    Object.defineProperty(this, "pageContent", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "metadata", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "id", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.pageContent = fields.pageContent !== void 0 ? fields.pageContent.toString() : "";
    this.metadata = fields.metadata ?? {};
    this.id = fields.id;
  }
};

// node_modules/ml-distance/lib-esm/similarities/czekanowski.js
function czekanowskiSimilarity(a, b) {
  let up = 0;
  let down = 0;
  for (let i = 0; i < a.length; i++) {
    up += Math.min(a[i], b[i]);
    down += a[i] + b[i];
  }
  return 2 * up / down;
}

// node_modules/ml-distance/lib-esm/distances/dice.js
function dice(a, b) {
  let a2 = 0;
  let b2 = 0;
  let prod2 = 0;
  for (let i = 0; i < a.length; i++) {
    a2 += a[i] * a[i];
    b2 += b[i] * b[i];
    prod2 += (a[i] - b[i]) * (a[i] - b[i]);
  }
  return prod2 / (a2 + b2);
}

// node_modules/ml-distance/lib-esm/distances/intersection.js
function intersection(a, b) {
  let ans = 0;
  for (let i = 0; i < a.length; i++) {
    ans += Math.min(a[i], b[i]);
  }
  return 1 - ans;
}

// node_modules/ml-distance/lib-esm/similarities/kumarHassebrook.js
function kumarHassebrook(a, b) {
  let p = 0;
  let p2 = 0;
  let q2 = 0;
  for (let i = 0; i < a.length; i++) {
    p += a[i] * b[i];
    p2 += a[i] * a[i];
    q2 += b[i] * b[i];
  }
  return p / (p2 + q2 - p);
}

// node_modules/ml-distance/lib-esm/distances/kulczynski.js
function kulczynski(a, b) {
  let up = 0;
  let down = 0;
  for (let i = 0; i < a.length; i++) {
    up += Math.abs(a[i] - b[i]);
    down += Math.min(a[i], b[i]);
  }
  return up / down;
}

// node_modules/ml-distance/lib-esm/distances/motyka.js
function motyka(a, b) {
  let up = 0;
  let down = 0;
  for (let i = 0; i < a.length; i++) {
    up += Math.min(a[i], b[i]);
    down += a[i] + b[i];
  }
  return 1 - up / down;
}

// node_modules/ml-distance/lib-esm/distances/squaredChord.js
function squaredChord(a, b) {
  let ans = 0;
  for (let i = 0; i < a.length; i++) {
    ans += (Math.sqrt(a[i]) - Math.sqrt(b[i])) ** 2;
  }
  return ans;
}

// node_modules/ml-distance/lib-esm/similarities/tanimoto.js
function tanimoto(a, b, bitvector) {
  if (bitvector) {
    let inter = 0;
    let union = 0;
    for (let j = 0; j < a.length; j++) {
      inter += a[j] && b[j];
      union += a[j] || b[j];
    }
    if (union === 0) {
      return 1;
    }
    return inter / union;
  } else {
    let p = 0;
    let q = 0;
    let m = 0;
    for (let i = 0; i < a.length; i++) {
      p += a[i];
      q += b[i];
      m += Math.min(a[i], b[i]);
    }
    return 1 - (p + q - 2 * m) / (p + q - m);
  }
}

// node_modules/ml-distance/lib-esm/similarities.js
var similarities_exports = {};
__export(similarities_exports, {
  cosine: () => cosine,
  czekanowski: () => czekanowskiSimilarity,
  dice: () => dice2,
  intersection: () => intersection2,
  kulczynski: () => kulczynski2,
  kumarHassebrook: () => kumarHassebrook,
  motyka: () => motyka2,
  pearson: () => pearson2,
  squaredChord: () => squaredChord2,
  tanimoto: () => tanimoto,
  tree: () => src_exports
});

// node_modules/ml-tree-similarity/src/index.js
var src_exports = {};
__export(src_exports, {
  createTree: () => createTree,
  getFunction: () => getFunction,
  treeSimilarity: () => treeSimilarity
});

// node_modules/ml-tree-similarity/src/createTree.js
var import_binary_search = __toESM(require_binary_search());
var import_num_sort = __toESM(require_num_sort());
function createTree(spectrum, options = {}) {
  var X = spectrum[0];
  const {
    minWindow = 0.16,
    threshold = 0.01,
    from = X[0],
    to = X[X.length - 1]
  } = options;
  return mainCreateTree(
    spectrum[0],
    spectrum[1],
    from,
    to,
    minWindow,
    threshold
  );
}
function mainCreateTree(X, Y, from, to, minWindow, threshold) {
  if (to - from < minWindow) {
    return null;
  }
  var start = (0, import_binary_search.default)(X, from, import_num_sort.ascending);
  if (start < 0) {
    start = ~start;
  }
  var sum2 = 0;
  var center = 0;
  for (var i = start; i < X.length; i++) {
    if (X[i] >= to) {
      break;
    }
    sum2 += Y[i];
    center += X[i] * Y[i];
  }
  if (sum2 < threshold) {
    return null;
  }
  center /= sum2;
  if (center - from < 1e-6 || to - center < 1e-6) {
    return null;
  }
  if (center - from < minWindow / 4) {
    return mainCreateTree(X, Y, center, to, minWindow, threshold);
  } else {
    if (to - center < minWindow / 4) {
      return mainCreateTree(X, Y, from, center, minWindow, threshold);
    } else {
      return new Tree(
        sum2,
        center,
        mainCreateTree(X, Y, from, center, minWindow, threshold),
        mainCreateTree(X, Y, center, to, minWindow, threshold)
      );
    }
  }
}
var Tree = class {
  constructor(sum2, center, left, right) {
    this.sum = sum2;
    this.center = center;
    this.left = left;
    this.right = right;
  }
};

// node_modules/ml-tree-similarity/src/getSimilarity.js
function getSimilarity(a, b, options = {}) {
  const { alpha = 0.1, beta = 0.33, gamma = 1e-3 } = options;
  if (a === null || b === null) {
    return 0;
  }
  if (Array.isArray(a)) {
    a = createTree(a);
  }
  if (Array.isArray(b)) {
    b = createTree(b);
  }
  var C = alpha * Math.min(a.sum, b.sum) / Math.max(a.sum, b.sum) + (1 - alpha) * Math.exp(-gamma * Math.abs(a.center - b.center));
  return beta * C + (1 - beta) * (getSimilarity(a.left, b.left, options) + getSimilarity(a.right, b.right, options)) / 2;
}

// node_modules/ml-tree-similarity/src/index.js
function treeSimilarity(A, B, options = {}) {
  return getSimilarity(A, B, options);
}
function getFunction(options = {}) {
  return (A, B) => getSimilarity(A, B, options);
}

// node_modules/ml-distance/lib-esm/similarities/cosine.js
function cosine(a, b) {
  let p = 0;
  let p2 = 0;
  let q2 = 0;
  for (let i = 0; i < a.length; i++) {
    p += a[i] * b[i];
    p2 += a[i] * a[i];
    q2 += b[i] * b[i];
  }
  return p / (Math.sqrt(p2) * Math.sqrt(q2));
}

// node_modules/ml-distance/lib-esm/similarities/dice.js
function dice2(a, b) {
  return 1 - dice(a, b);
}

// node_modules/ml-distance/lib-esm/similarities/intersection.js
function intersection2(a, b) {
  return 1 - intersection(a, b);
}

// node_modules/ml-distance/lib-esm/similarities/kulczynski.js
function kulczynski2(a, b) {
  return 1 / kulczynski(a, b);
}

// node_modules/ml-distance/lib-esm/similarities/motyka.js
function motyka2(a, b) {
  return 1 - motyka(a, b);
}

// node_modules/is-any-array/lib-esm/index.js
var toString = Object.prototype.toString;
function isAnyArray(value) {
  const tag = toString.call(value);
  return tag.endsWith("Array]") && !tag.includes("Big");
}

// node_modules/ml-array-sum/lib-es6/index.js
function sum(input) {
  if (!isAnyArray(input)) {
    throw new TypeError("input must be an array");
  }
  if (input.length === 0) {
    throw new TypeError("input must not be empty");
  }
  var sumValue = 0;
  for (var i = 0; i < input.length; i++) {
    sumValue += input[i];
  }
  return sumValue;
}

// node_modules/ml-array-mean/lib-es6/index.js
function mean(input) {
  return sum(input) / input.length;
}

// node_modules/ml-distance/lib-esm/similarities/pearson.js
function pearson2(a, b) {
  let avgA = mean(a);
  let avgB = mean(b);
  let newA = new Array(a.length);
  let newB = new Array(b.length);
  for (let i = 0; i < newA.length; i++) {
    newA[i] = a[i] - avgA;
    newB[i] = b[i] - avgB;
  }
  return cosine(newA, newB);
}

// node_modules/ml-distance/lib-esm/similarities/squaredChord.js
function squaredChord2(a, b) {
  return 1 - squaredChord(a, b);
}

// node_modules/@langchain/core/dist/utils/math.js
function matrixFunc(X, Y, func) {
  if (X.length === 0 || X[0].length === 0 || Y.length === 0 || Y[0].length === 0) {
    return [[]];
  }
  if (X[0].length !== Y[0].length) {
    throw new Error(`Number of columns in X and Y must be the same. X has shape ${[
      X.length,
      X[0].length
    ]} and Y has shape ${[Y.length, Y[0].length]}.`);
  }
  return X.map((xVector) => Y.map((yVector) => func(xVector, yVector)).map((similarity) => Number.isNaN(similarity) ? 0 : similarity));
}
function cosineSimilarity(X, Y) {
  return matrixFunc(X, Y, similarities_exports.cosine);
}
function maximalMarginalRelevance(queryEmbedding, embeddingList, lambda = 0.5, k = 4) {
  if (Math.min(k, embeddingList.length) <= 0) {
    return [];
  }
  const queryEmbeddingExpanded = Array.isArray(queryEmbedding[0]) ? queryEmbedding : [queryEmbedding];
  const similarityToQuery = cosineSimilarity(queryEmbeddingExpanded, embeddingList)[0];
  const mostSimilarEmbeddingIndex = argMax(similarityToQuery).maxIndex;
  const selectedEmbeddings = [embeddingList[mostSimilarEmbeddingIndex]];
  const selectedEmbeddingsIndexes = [mostSimilarEmbeddingIndex];
  while (selectedEmbeddingsIndexes.length < Math.min(k, embeddingList.length)) {
    let bestScore = -Infinity;
    let bestIndex = -1;
    const similarityToSelected = cosineSimilarity(embeddingList, selectedEmbeddings);
    similarityToQuery.forEach((queryScore, queryScoreIndex) => {
      if (selectedEmbeddingsIndexes.includes(queryScoreIndex)) {
        return;
      }
      const maxSimilarityToSelected = Math.max(...similarityToSelected[queryScoreIndex]);
      const score = lambda * queryScore - (1 - lambda) * maxSimilarityToSelected;
      if (score > bestScore) {
        bestScore = score;
        bestIndex = queryScoreIndex;
      }
    });
    selectedEmbeddings.push(embeddingList[bestIndex]);
    selectedEmbeddingsIndexes.push(bestIndex);
  }
  return selectedEmbeddingsIndexes;
}
function argMax(array) {
  if (array.length === 0) {
    return {
      maxIndex: -1,
      maxValue: NaN
    };
  }
  let maxValue = array[0];
  let maxIndex = 0;
  for (let i = 1; i < array.length; i += 1) {
    if (array[i] > maxValue) {
      maxIndex = i;
      maxValue = array[i];
    }
  }
  return { maxIndex, maxValue };
}

// node_modules/@langchain/community/dist/vectorstores/supabase.js
var SupabaseVectorStore = class _SupabaseVectorStore extends VectorStore {
  _vectorstoreType() {
    return "supabase";
  }
  constructor(embeddings, args) {
    super(embeddings, args);
    Object.defineProperty(this, "client", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "tableName", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "queryName", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "filter", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "upsertBatchSize", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 500
    });
    this.client = args.client;
    this.tableName = args.tableName || "documents";
    this.queryName = args.queryName || "match_documents";
    this.filter = args.filter;
    this.upsertBatchSize = args.upsertBatchSize ?? this.upsertBatchSize;
  }
  /**
   * Adds documents to the vector store.
   * @param documents The documents to add.
   * @param options Optional parameters for adding the documents.
   * @returns A promise that resolves when the documents have been added.
   */
  async addDocuments(documents, options) {
    const texts = documents.map(({ pageContent }) => pageContent);
    return this.addVectors(await this.embeddings.embedDocuments(texts), documents, options);
  }
  /**
   * Adds vectors to the vector store.
   * @param vectors The vectors to add.
   * @param documents The documents associated with the vectors.
   * @param options Optional parameters for adding the vectors.
   * @returns A promise that resolves with the IDs of the added vectors when the vectors have been added.
   */
  async addVectors(vectors, documents, options) {
    const rows = vectors.map((embedding, idx) => ({
      content: documents[idx].pageContent,
      embedding,
      metadata: documents[idx].metadata
    }));
    let returnedIds = [];
    for (let i = 0; i < rows.length; i += this.upsertBatchSize) {
      const chunk = rows.slice(i, i + this.upsertBatchSize).map((row, j) => {
        if (options == null ? void 0 : options.ids) {
          return { id: options.ids[i + j], ...row };
        }
        return row;
      });
      const res = await this.client.from(this.tableName).upsert(chunk).select();
      if (res.error) {
        throw new Error(`Error inserting: ${res.error.message} ${res.status} ${res.statusText}`);
      }
      if (res.data) {
        returnedIds = returnedIds.concat(res.data.map((row) => row.id));
      }
    }
    return returnedIds;
  }
  /**
   * Deletes vectors from the vector store.
   * @param params The parameters for deleting vectors.
   * @returns A promise that resolves when the vectors have been deleted.
   */
  async delete(params) {
    const { ids } = params;
    for (const id of ids) {
      await this.client.from(this.tableName).delete().eq("id", id);
    }
  }
  async _searchSupabase(query, k, filter) {
    if (filter && this.filter) {
      throw new Error("cannot provide both `filter` and `this.filter`");
    }
    const _filter = filter ?? this.filter ?? {};
    const matchDocumentsParams = {
      query_embedding: query
    };
    let filterFunction;
    if (typeof _filter === "function") {
      filterFunction = (rpcCall2) => _filter(rpcCall2).limit(k);
    } else if (typeof _filter === "object") {
      matchDocumentsParams.filter = _filter;
      matchDocumentsParams.match_count = k;
      filterFunction = (rpcCall2) => rpcCall2;
    } else {
      throw new Error("invalid filter type");
    }
    const rpcCall = this.client.rpc(this.queryName, matchDocumentsParams);
    const { data: searches, error } = await filterFunction(rpcCall);
    if (error) {
      throw new Error(`Error searching for documents: ${error.code} ${error.message} ${error.details}`);
    }
    return searches;
  }
  /**
   * Performs a similarity search on the vector store.
   * @param query The query vector.
   * @param k The number of results to return.
   * @param filter Optional filter to apply to the search.
   * @returns A promise that resolves with the search results when the search is complete.
   */
  async similaritySearchVectorWithScore(query, k, filter) {
    const searches = await this._searchSupabase(query, k, filter);
    const result = searches.map((resp) => [
      new Document({
        metadata: resp.metadata,
        pageContent: resp.content
      }),
      resp.similarity
    ]);
    return result;
  }
  /**
   * Return documents selected using the maximal marginal relevance.
   * Maximal marginal relevance optimizes for similarity to the query AND diversity
   * among selected documents.
   *
   * @param {string} query - Text to look up documents similar to.
   * @param {number} options.k - Number of documents to return.
   * @param {number} options.fetchK=20- Number of documents to fetch before passing to the MMR algorithm.
   * @param {number} options.lambda=0.5 - Number between 0 and 1 that determines the degree of diversity among the results,
   *                 where 0 corresponds to maximum diversity and 1 to minimum diversity.
   * @param {SupabaseLibArgs} options.filter - Optional filter to apply to the search.
   *
   * @returns {Promise<Document[]>} - List of documents selected by maximal marginal relevance.
   */
  async maxMarginalRelevanceSearch(query, options) {
    const queryEmbedding = await this.embeddings.embedQuery(query);
    const searches = await this._searchSupabase(queryEmbedding, options.fetchK ?? 20, options.filter);
    const embeddingList = searches.map((searchResp) => searchResp.embedding);
    const mmrIndexes = maximalMarginalRelevance(queryEmbedding, embeddingList, options.lambda, options.k);
    return mmrIndexes.map((idx) => new Document({
      metadata: searches[idx].metadata,
      pageContent: searches[idx].content
    }));
  }
  /**
   * Creates a new SupabaseVectorStore instance from an array of texts.
   * @param texts The texts to create documents from.
   * @param metadatas The metadata for the documents.
   * @param embeddings The embeddings to use.
   * @param dbConfig The configuration for the Supabase database.
   * @returns A promise that resolves with a new SupabaseVectorStore instance when the instance has been created.
   */
  static async fromTexts(texts, metadatas, embeddings, dbConfig) {
    const docs = [];
    for (let i = 0; i < texts.length; i += 1) {
      const metadata = Array.isArray(metadatas) ? metadatas[i] : metadatas;
      const newDoc = new Document({
        pageContent: texts[i],
        metadata
      });
      docs.push(newDoc);
    }
    return _SupabaseVectorStore.fromDocuments(docs, embeddings, dbConfig);
  }
  /**
   * Creates a new SupabaseVectorStore instance from an array of documents.
   * @param docs The documents to create the instance from.
   * @param embeddings The embeddings to use.
   * @param dbConfig The configuration for the Supabase database.
   * @returns A promise that resolves with a new SupabaseVectorStore instance when the instance has been created.
   */
  static async fromDocuments(docs, embeddings, dbConfig) {
    const instance = new this(embeddings, dbConfig);
    await instance.addDocuments(docs);
    return instance;
  }
  /**
   * Creates a new SupabaseVectorStore instance from an existing index.
   * @param embeddings The embeddings to use.
   * @param dbConfig The configuration for the Supabase database.
   * @returns A promise that resolves with a new SupabaseVectorStore instance when the instance has been created.
   */
  static async fromExistingIndex(embeddings, dbConfig) {
    const instance = new this(embeddings, dbConfig);
    return instance;
  }
};
export {
  SupabaseVectorStore
};
//# sourceMappingURL=@langchain_community_vectorstores_supabase.js.map
